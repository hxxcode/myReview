lsm树牺牲部分读取能力来大幅提高写入数据能力。
核心思想：LSM树原理把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。假定内存足够大，因此不需要每次有数据库数据更新就必须将数据写入到磁盘中，而可以先将最新的数据驻留在内存中。等到积累到足够多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾(因为所有待排序的树都是有序的，通过归并排序可以快速完成)。
内存和磁盘中的数据merge：

将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。
对磁盘来说，我们一次性读取一大块数据，一次性写入一批数据比每次只要有更新就写入磁盘可以明显减少磁盘io操作，提高写入性能。
 
数据读取过程：
LSM Tree将一颗树分为许多有序的树，比如每m个数据，在内存里排序一次，这样依次做下去，我就可以获得N/m个有序的小的树。
在查询的时候，因为不知道这个数据到底是在哪里，所以就从最新的一个小的有序结构里做二分查找，找得到就返回，找不到就继续找下一个小有序结构，一直到找到为止。读取的时间复杂度是(N/m)*log2N 。读取效率是会下降的。
 
优化
提供一个进程，专门不断将小树进行合并，合并成较大的有序的树，减少这样当树只有一个时时间复杂度为log2N
 
